## نحوه اجرای کد در Lua

زبان Lua یک زبان برنامه‌نویسی تفسیر شده است. این بدان معناست که کد منبع Lua مستقیماً توسط یک برنامه به نام مفسر Lua خط به خط خوانده و اجرا می‌شود. برخلاف زبان‌های کامپایلری مانند C++ که ابتدا کل کد به یک فایل اجرایی مستقل (باینری) تبدیل می‌شود، در Lua نیازی به این مرحله نیست.

## تفسیر یا Interpretation


تصور کنید یک آشپز دارید که دستور پخت یک غذا را مستقیماً از روی کتاب می‌خواند و همان لحظه هر مرحله را اجرا می‌کند. او ابتدا مواد لازم را آماده می‌کند، سپس طبق دستور، آن‌ها را با هم مخلوط می‌کند، بعد حرارت می‌دهد و به همین ترتیب تا انتهای دستور پیش می‌رود. در این مثال، کتاب دستور پخت مانند فایل کد منبع Lua است و آشپز نقش مفسر Lua را ایفا می‌کند.

به طور خلاصه، تفسیر در Lua به این معنی است که مفسر Lua مراحل زیر را برای اجرای کد شما انجام می‌دهد:

خواندن خط به خط: مفسر فایل .lua شما را از ابتدا تا انتها، خط به خط می‌خواند.

تجزیه و تحلیل (Parsing): هر خطی که خوانده می‌شود، توسط مفسر تجزیه و تحلیل می‌شود تا ساختار دستوری آن بررسی شود. مفسر مطمئن می‌شود که دستورات به درستی نوشته شده‌اند و با قواعد زبان Lua مطابقت دارند. اگر خطایی در دستور وجود داشته باشد (مثلاً اشتباه تایپی در یک کلمه کلیدی)، مفسر معمولاً در همین مرحله یک پیغام خطا می‌دهد و اجرای برنامه متوقف می‌شود.

اجرا (Execution): پس از تجزیه و تحلیل موفقیت‌آمیز یک خط، مفسر بلافاصله آن دستور را اجرا می‌کند. این اجرا می‌تواند شامل انجام محاسبات، تغییر مقدار متغیرها، فراخوانی توابع، کنترل جریان برنامه (مانند اجرای حلقه‌ها یا دستورات شرطی) و تعامل با سیستم عامل باشد.

تکرار: این فرآیند (خواندن، تجزیه و تحلیل، اجرا) برای تمام خطوط موجود در فایل .lua تکرار می‌شود تا زمانی که به انتهای فایل برسد یا دستور توقف اجرای برنامه (مانند return در یک تابع اصلی یا بروز خطا) فرا رسد.
ویژگی‌های کلیدی تفسیر در Lua:

* اجرای مستقیم: کد بلافاصله پس از خوانده شدن و تجزیه شدن اجرا می‌شود. نیازی به یک مرحله جداگانه برای تولید کد ماشین یا فایل اجرایی نیست.
* انعطاف‌پذیری و پویایی: زبان‌های تفسیر شده معمولاً انعطاف‌پذیرتر هستند و امکاناتی مانند تغییر نوع متغیرها در زمان اجرا (dynamic typing) را فراهم می‌کنند. Lua نیز از این ویژگی‌ها بهره می‌برد.
* سهولت در توسعه و آزمایش: توسعه‌دهندگان می‌توانند به سرعت تغییرات در کد خود اعمال کرده و بلافاصله نتیجه را بدون نیاز به کامپایل مجدد مشاهده کنند. این امر فرآیند توسعه و رفع اشکال را تسریع می‌بخشد.
* وابستگی به مفسر: برای اجرای کد Lua، وجود مفسر Lua بر روی سیستم ضروری است. کد Lua به خودی خود یک برنامه اجرایی مستقل نیست.
* عملکرد (Performance): به طور کلی، زبان‌های تفسیر شده ممکن است در مقایسه با زبان‌های کامپایلری که کد آن‌ها مستقیماً توسط پردازنده اجرا می‌شود، عملکرد پایین‌تری داشته باشند. دلیل این امر این است که فرآیند تجزیه و تحلیل در هر بار اجرا تکرار می‌شود. با این حال، Lua به دلیل طراحی کارآمد ماشین مجازی خود، عملکرد نسبتاً خوبی در بین زبان‌های تفسیر شده دارد.
+ در واقع، مفسر Lua مانند یک مترجم همزمان عمل می‌کند که هر جمله از کد شما را می‌خواند، آن را درک می‌کند و بلافاصله دستورات آن را انجام می‌دهد. این فرآیند گام به گام، تفسیر نامیده می‌شود.

## امکان کامپایل به Bytecode

اگرچه Lua در درجه اول یک زبان تفسیر شده است، اما این امکان را فراهم می‌کند که کد منبع به یک بایت‌کد میانی کامپایل شود. بایت‌کد یک زبان سطح پایین‌تر و مستقل از سخت‌افزار است که برای ماشین مجازی Lua بهینه شده است. این مرحله کامپایل اختیاری است و معمولاً برای بهبود عملکرد در برنامه‌های بزرگ یا توزیع کد بدون افشای کد منبع اصلی استفاده می‌شود. خروجی این کامپایل معمولاً در فایل‌هایی با پسوند .luac ذخیره می‌شود.

## اجرای بایت کد توسط ماشین مجازی Lua

هنگامی که کد Lua به بایت‌کد کامپایل می‌شود (یا حتی زمانی که کد منبع مستقیماً اجرا می‌شود)، در نهایت این بایت‌کد توسط یک ماشین مجازی (Virtual Machine) به نام VM Lua اجرا می‌شود. VM Lua یک محیط اجرایی انتزاعی است که دستورالعمل‌های بایت‌کد را پردازش و اجرا می‌کند. این معماری باعث می‌شود که Lua بسیار قابل حمل باشد، زیرا VM Lua می‌تواند بر روی سیستم‌عامل‌ها و معماری‌های مختلف سخت‌افزاری پیاده‌سازی شود.

## به طور خلاصه، چرخه اجرای کد در Lua می‌تواند به این صورت باشد:

* توسعه: نوشتن کد منبع Lua در فایل‌های .lua.
 * (اختیاری) کامپایل: تبدیل کد منبع به بایت‌کد (.luac) توسط مفسر Lua.
 * اجرا: اجرای کد (چه منبع و چه بایت‌کد) توسط ماشین مجازی Lua که درون مفسر Lua قرار دارد.
 * تعریف و استفاده از توابع در Lua

## توابع در lua
در Lua، توابع بلوک‌هایی از کد هستند که برای انجام یک وظیفه خاص طراحی شده‌اند. تعریف تابع در Lua به صورت زیر است:
```lua
function نام_تابع(پارامتر1, پارامتر2, ...)
  -- بدنه تابع (دستوراتی که اجرا می‌شوند)
  return مقدار_بازگشتی -- (اختیاری)
end
```

برای فراخوانی (اجرا) یک تابع، کافی است نام آن را به همراه پرانتز و آرگومان‌های مورد نیاز (در صورت وجود) بنویسید:
```lua
variable = نام_تابع(آرگومان1, آرگومان2, ...)
```
## توابع درجه اول (First-Class Functions)

یکی از ویژگی‌های قدرتمند Lua این است که توابع در آن به عنوان مقادیر درجه اول در نظر گرفته می‌شوند. این بدان معناست که:

* می‌توانید توابع را به متغیرها اختصاص دهید:
```lua
myFunction = function(x)
  return x * 2
end
print(myFunction(5)) -- خروجی: 10
```
* می‌توانید توابع را به عنوان آرگومان به توابع دیگر ارسال کنید:
```lua
function applyOperation(func, value)
  return func(value)
end

function square(x)
  return x * x
end

result = applyOperation(square, 3)
print(result) -- خروجی: 9
```
* می‌توانید توابع را از توابع دیگر برگردانید:
```lua
function createMultiplier(factor)
  return function(x)
    return x * factor
  end
end

multiplyByThree = createMultiplier(3)
print(multiplyByThree(4)) -- خروجی: 12
```
این ویژگی توابع درجه اول، امکان استفاده از الگوهای برنامه‌نویسی تابعی و ایجاد کدهای انعطاف‌پذیر و قدرتمند را فراهم می‌کند.
## Closures
هنگامی که یک تابع در داخل تابع دیگری تعریف می‌شود، تابع داخلی می‌تواند به متغیرهای محلی تابع بیرونی دسترسی داشته باشد، حتی پس از اینکه اجرای تابع بیرونی به پایان رسیده باشد. به این ترکیب از یک تابع و محیط پیرامون آن (متغیرهای محلی غیرمحصور) یک Closure گفته می‌شود.
```lua
function counter()
  local count = 0
  return function()
    count = count + 1
    return count
  end
end

local myCounter = counter()
print(myCounter()) -- خروجی: 1
print(myCounter()) -- خروجی: 2
```
در این مثال، تابع داخلی به متغیر count که در تابع counter تعریف شده است دسترسی دارد و مقدار آن را در هر بار فراخوانی به‌روزرسانی می‌کند، حتی پس از اینکه تابع counter اجرا شده و به پایان رسیده است.

این Closures برای ایجاد توابع با حافظه داخلی و پیاده‌سازی مفاهیمی مانند توابع مولد (generators) بسیار مفید هستند.

## OOP در Lua

زبان برنامه نویسی Lua به طور ذاتی یک زبان شیءگرا (Object-Oriented) نیست، اما امکان پیاده‌سازی مفاهیم OOP را از طریق جداول و توابع فراهم می‌کند. روش معمول برای شبیه‌سازی کلاس‌ها و اشیاء در Lua استفاده از جداول برای نگهداری داده‌ها (ویژگی‌ها) و توابع برای تعریف رفتارها (متدها) است.
یک روش رایج برای ایجاد "اشیاء" استفاده از یک جدول به عنوان نمونه و یک جدول دیگر به عنوان "کلاس" است که شامل متدها می‌شود.
```lua

Rectangle = { area = function(self) return self.width * self.height end }
-- تعریف یک "کلاس" ساده به نام Rectangle
function Rectangle:new(width, height)
  local obj = { width = width, height = height }
  setmetatable(obj, { __index = self })
  return obj
end

-- ایجاد یک شیء از نوع Rectangle
local rect1 = Rectangle:new(10, 5)
print(rect1:area()) -- خروجی: 50
```
در این مثال، Rectangle هم به عنوان یک جدول برای نگهداری متدها و هم به عنوان یک نوع "کلاس" عمل می‌کند. متد new یک شیء جدید ایجاد می‌کند و метаجدول آن را به Rectangle متصل می‌کند. استفاده از : در تعریف و فراخوانی متدها، آرگومان ضمنی self را به تابع ارسال می‌کند که به شیء مورد نظر اشاره دارد.

